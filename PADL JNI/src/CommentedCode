	// Method that check if all the natives methods have an implementation in
	// C++ files, in others words for each
	// native methods we check if there is a JNI implementation in a c++ files.
	/*public static ArrayList<String> NativeMissed(ArrayList<String> listNative, ArrayList<String> listJNI) {
		final ArrayList<String> JniNativeIntersect = new ArrayList<String>();
		Iterator it = listNative.iterator();
		while (it.hasNext()) {
			Object o = it.next();
			if (!listJNI.contains(o)) {
				JniNativeIntersect.add((String) o);
			}
		}

		return JniNativeIntersect;
	}*/

	// The opposite direction of NativeMissed.
	/*public static ArrayList<String> JNIMissed(ArrayList<String> listNative, ArrayList<String> listJNI) {
		final ArrayList<String> NativeIntersect = new ArrayList<String>();
		Iterator it = listJNI.iterator();
		while (it.hasNext()) {
			Object o = it.next();
			if (!listNative.contains(o)) {
				NativeIntersect.add((String) o);
			}
		}

		return NativeIntersect;
	}*/
	
	
	
	// The testCases
	// The same method as 'NativeMissed' but here we use it for our test case to
	// count the number of natives methods
	// that don't have a JNI implementation in a c++ files.
	/*public int NativeMissedTestCase() throws CreationException {
		ICodeLevelModel hybrid = this.CreateModelTestCase();
		final IWalker nativeAnalysis = new JNICollecteNativeVisitor();
		hybrid.walk(nativeAnalysis);
		final ArrayList<String> listOfNativeMethods = (ArrayList<String>) nativeAnalysis.getResult();
		final IWalker globalesAnalysis = new JNICollecteFctGlobaleVisitor();
		hybrid.walk(globalesAnalysis);
		final ArrayList<String> listOfJNIMethods = (ArrayList<String>) globalesAnalysis.getResult();
		final ArrayList<String> JniNativeIntersect = new ArrayList<String>();
		Iterator it = listOfNativeMethods.iterator();
		while (it.hasNext()) {
			Object o = it.next();
			if (!listOfJNIMethods.contains(o)) {
				JniNativeIntersect.add((String) o);
			}
		}

		return JniNativeIntersect.size();
	}*/

	// a Method used for the test case to count the number of JNI methods exist
	// in C++ files that they don't have
	// a native declaration in java files. (the opposite direction of
	// NativeMissedTestCase).
	/*public int JNIMissedTestCase() throws CreationException {
		ICodeLevelModel hybrid = this.CreateModelTestCase();
		final IWalker nativeAnalysis = new JNICollecteNativeVisitor();
		hybrid.walk(nativeAnalysis);
		final ArrayList<String> listOfNativeMethods = (ArrayList<String>) nativeAnalysis.getResult();
		final IWalker globalesAnalysis = new JNICollecteFctGlobaleVisitor();
		hybrid.walk(globalesAnalysis);
		final ArrayList<String> listOfJNIMethods = (ArrayList<String>) globalesAnalysis.getResult();
		final ArrayList<String> NativeIntersect = new ArrayList<String>();
		Iterator it = listOfJNIMethods.iterator();
		while (it.hasNext()) {
			Object o = it.next();
			if (!listOfNativeMethods.contains(o)) {
				NativeIntersect.add((String) o);
			}
		}

		return NativeIntersect.size();
	}*/

	// This method is used in the Test Case and it allow us to return the Model
	// Hybrid which contain the constituents
	// for Java files and C++ files.
	public ICodeLevelModel CreateModelTestCase() throws CreationException {
		final String apathJ = "C:/Users/manel/Desktop/TheseManel/Recherche/My Papers/CASCON17/Saner2017/jnianalyser/systems/Telegram/TMessagesProj/src/main";
		final String apathC = "C:/Users/manel/Desktop/TheseManel/Recherche/My Papers/CASCON17/Saner2017/jnianalyser/systems/Telegram/TMessagesProj/jni";
		final ICodeLevelModel hybrid = Factory.getInstance().createCodeLevelModel("Hybrid");
		final ICodeLevelModelCreator javaCreator = new CompleteJavaFileCreator(apathJ, "");
		javaCreator.create(hybrid);
		final ICodeLevelModelCreator cppCreator = new CPPCreator(apathC);
		cppCreator.create(hybrid);
		return (hybrid);
	}

	// Method used in the test case and which give the number of natives methods
	// existing in java files.
	public int NBNative() throws CreationException {
		ICodeLevelModel model = this.CreateModelTestCase();
		final IWalker nativeAnalysis = new JNICollecteNativeVisitor();
		model.walk(nativeAnalysis);
		final ArrayList<String> listOfNativeMethods = (ArrayList<String>) nativeAnalysis.getResult();
		return listOfNativeMethods.size();
	}
	
	
	// Method used in the test case and which give the number of JNI methods
	// basing on the parameter JNIENV.
	/*public int NBFctGlobale() throws CreationException {
		ICodeLevelModel model = this.CreateModelTestCase();
		final IWalker globalesAnalysis = new JNICollecteFctGlobaleVisitor();
		model.walk(globalesAnalysis);
		final ArrayList<String> listOfJNIMethods = (ArrayList<String>) globalesAnalysis.getResult();
		return listOfJNIMethods.size();
	}*/
	
	
	
	
	/*
		 * System.out.
		 * println("********************List of JNI Methods***********************"
		 * );//PB: pas d'affichage des methodes globales qui retournent Void
		 * final IWalker globalesAnalysis = new JNICollecteFctGlobaleVisitor();
		 * hybrid.walk(globalesAnalysis); final ArrayList<String>
		 * listOfJNIMethods = (ArrayList<String>) globalesAnalysis.getResult();
		 * System.out.println(listOfJNIMethods.size());
		 * System.out.println(listOfJNIMethods);
		 * 
		 * System.out.
		 * println("******************List of Native Methods Missed on JNI methods**************************"
		 * ); System.out.println(NativeMissed(listOfNativeMethods,
		 * listOfJNIMethods).size());
		 * System.out.println(NativeMissed(listOfNativeMethods,
		 * listOfJNIMethods));
		 * 
		 * System.out.
		 * println("******************List of JNI Methods Missed on Natives methods**************************"
		 * ); System.out.println(JNIMissed(listOfNativeMethods,
		 * listOfJNIMethods).size());
		 * System.out.println(JNIMissed(listOfNativeMethods, listOfJNIMethods));
		 */